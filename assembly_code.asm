# ======================== 冒泡排序 ========================

#     汇编指令           ->            二进制机器码                     (16进制)
# addiu $8, $0, 4       -> 100001 00000 01000 0000000000000100      (0x84080004)
# addiu $3, $0, 0       -> 100001 00000 00011 0000000000000000      (0x84030000)
# jal   0x00000064      -> 011110 00000000000000000000011001        (0x78000019)
# beq   $3, $8, 15      -> 011000 00011 01000 0000000000001111      (0x6068000F)
# sub   $9, $8, $3      -> 000000 01000 00011 01001 00000 100010    (0x01034822)
# addiu $4, $0, 0       -> 100001 00000 00100 0000000000000000      (0x84040000)
# addiu $5, $0, 0       -> 100001 00000 00101 0000000000000000      (0x84050000)
# beq   $4, $9, 9       -> 011000 00100 01001 0000000000001001      (0x60890009)
# sll   $5, $4, 2       -> 000000 00000 00100 0010100010000100      (0x00042884)
# lw    $1, 0($5)       -> 010001 00101 00001 0000000000000000      (0x44A10000)
# lw    $2, 4($5)       -> 010001 00101 00010 0000000000000100      (0x44A20004)
# slt   $6, $2, $1      -> 000000 00010 00001 00110 00000 000010    (0x00413002)
# beq   $6, $0, 2       -> 011000 00110 00000 0000000000000010      (0x60C00002)
# sw    $1, 4($5)       -> 010000 00101 00001 0000000000000100      (0x40A10004)
# sw    $2, 0($5)       -> 010000 00101 00010 0000000000000000      (0x40A20000)
# addiu $4, $4, 1       -> 100001 00100 00100 0000000000000001      (0x84840001)
# j     0x0000001c      -> 011100 00000000000000000000000111        (0x70000007)
# addiu $3, $3, 1       -> 100001 00011 00011 0000000000000001      (0x84630001)
# j     0x0000000c      -> 011100 00000000000000000000000011        (0x70000003)
# lw    $7, 0($0)       -> 010001 00000 00111 0000000000000000      (0x44070000)
# lw    $7, 4($0)       -> 010001 00000 00111 0000000000000100      (0x44070004)
# lw    $7, 8($0)       -> 010001 00000 00111 0000000000001000      (0x44070008)
# lw    $7, 12($0)      -> 010001 00000 00111 0000000000001100      (0x4407000c)
# lw    $7, 16($0)      -> 010001 00000 00111 0000000000010000      (0x44070010)
# halt                  -> 111111 00000000000000000000000000        (0xFC000000)
# ori   $7, $0, 3       -> 001001 00000 00111 0000000000000011      (0x24070003)
# sw    $7, 0($0)       -> 010000 00000 00111 0000000000000000      (0x40070000)
# ori   $7, $0, 4       -> 001001 00000 00111 0000000000000100      (0x24070004)
# sw    $7, 4($0)       -> 010000 00000 00111 0000000000000100      (0x40070004)
# ori   $7, $0, 5       -> 001001 00000 00111 0000000000000101      (0x24070005)
# sw    $7, 8($0)       -> 010000 00000 00111 0000000000001000      (0x40070008)
# ori   $7, $0, 6       -> 001001 00000 00111 0000000000000110      (0x24070006)
# sw    $7, 12($0)      -> 010000 00000 00111 0000000000001100      (0x4007000c)
# ori   $7, $0, 2       -> 001001 00000 00111 0000000000000010      (0x24070002)
# sw    $7, 16($0)      -> 010000 00000 00111 0000000000010000      (0x40070010)
# jr    $31             -> 011101 11111 000000000000000000000       (0x77E00000)

# ======================== 各寄存器功能 ========================
# $1 = array[addr]
# $2 = array[addr + 1]
# $3 = i
# $4 = j, j表示数组中的第j个元素(从0开始)
# $5 = addr = j << 2, 表示该元素在数组中的地址 ($4,$5必须同时变化)
# $6 = array[addr + 1] < array[addr] 时，$6 = 1
# $7 = 输入/输出数组临时寄存器
# $8 = n - 1
# $9 = n - i - 1
# $31 = 返回地址

# init(0x00):
    addiu   $8, $0, 4           # (0x00) $8 = n-1 = 4
    addiu   $3, $0, 0           # (0x04) i = 0
    jal     0x00000064          # (0x08) 初始化数组, GOTO load_array

# outer_loop(0x0c):
    # for (i = 0; i != n-1; i++)
    beq     $3, $8, 15          # (0x0c) if i == n-1, GOTO end_outer_loop
    sub     $9, $8, $3          # (0x10) $9 = n-i-1
    addiu   $4, $0, 0           # (0x14) j = 0
    addiu   $5, $0, 0           # (0x18) addr = 0

# inner_loop(0x1c):
    # for (j = 0; j != n-i-1; j++)
    beq     $4, $9, 9           # (0x1c) if j == n-i-1, GOTO end_inner_loop
    # get array elements
    sll     $5, $4, 2           # (0x20) addr = j << 2
    lw      $1, 0($5)           # (0x24) $1 = array[addr]
    lw      $2, 4($5)           # (0x28) $2 = array[addr + 1]
    # compare
    slt     $6, $2, $1          # (0x2c) $6 = (array[addr+1] < array[addr]) ? 1 : 0
    beq     $6, $0, 2           # (0x30) if $6 == 0(不交换), GOTO no_swap
    # swap
    sw      $1, 4($5)           # (0x34) array[addr+1] = $1
    sw      $2, 0($5)           # (0x38) array[addr] = $2

# no_swap(0x3c):
    addiu   $4, $4, 1           # (0x3c) j++
    j       0x0000001c          # (0x40) GOTO inner_loop

# end_inner_loop(0x44):
    addiu   $3, $3, 1           # (0x44) i++
    j       0x0000000c          # (0x48) GOTO outer_loop

# end_outer_loop(0x4c):
    # 方便从仿真波形中观察排序后的数组
    lw      $7, 0($0)           # (0x4c) $7 = array[0]
    lw      $7, 4($0)           # (0x50) $7 = array[1]
    lw      $7, 8($0)           # (0x54) $7 = array[2]
    lw      $7, 12($0)          # (0x58) $7 = array[3]
    lw      $7, 16($0)          # (0x5c) $7 = array[4]
    halt                        # (0x60) 程序终止

# load_array(0x64):
    ori     $7, $0, 3           # (0x64) 
    sw      $7, 0($0)           # (0x68) array[0] = 3
    ori     $7, $0, 4           # (0x6c) 
    sw      $7, 4($0)           # (0x70) array[1] = 4
    ori     $7, $0, 5           # (0x74) 
    sw      $7, 8($0)           # (0x78) array[2] = 5
    ori     $7, $0, 6           # (0x7c) 
    sw      $7, 12($0)          # (0x80) array[3] = 6
    ori     $7, $0, 2           # (0x84) 
    sw      $7, 16($0)          # (0x88) array[4] = 2
    jr      $31                 # (0x8c) 返回
